pub(crate) const AFTER_HELP_STR: &str = concat!(
    "       N and BYTES may be followed by the following multiplicative\n",
    "       suffixes: c=1, w=2, b=512, kB=1000, K=1024, MB=1000*1000,\n",
    "       M=1024*1024, xM=M, GB=1000*1000*1000, G=1024*1024*1024, and so on\n",
    "       for T, P, E, Z, Y.  Binary prefixes can be used, too: KiB=K,\n",
    "       MiB=M, and so on.\n",
    "\n",
    "       Each \x1b[0;33;1mCONV\x1b[0m symbol may be:\n",
    "\n",
    "       \x1b[0;32;1mascii\x1b[0m  from EBCDIC to ASCII\n",
    "\n",
    "       \x1b[0;32;1mebcdic\x1b[0m from ASCII to EBCDIC\n",
    "\n",
    "       \x1b[0;32;1mibm\x1b[0m    from ASCII to alternate EBCDIC\n",
    "\n",
    "       \x1b[0;32;1mblock\x1b[0m  pad newline-terminated records with spaces to cbs-size\n",
    "\n",
    "       \x1b[0;32;1munblock\x1b[0m\n",
    "              replace trailing spaces in cbs-size records with newline\n",
    "\n",
    "       \x1b[0;32;1mlcase\x1b[0m  change upper case to lower case\n",
    "\n",
    "       \x1b[0;32;1mucase\x1b[0m  change lower case to upper case\n",
    "\n",
    "       \x1b[0;32;1msparse\x1b[0m try to seek rather than write all-NUL output blocks\n",
    "\n",
    "       \x1b[0;32;1mswab\x1b[0m   swap every pair of input bytes\n",
    "\n",
    "       \x1b[0;32;1msync\x1b[0m   pad every input block with NULs to ibs-size; when used\n",
    "              with block or unblock, pad with spaces rather than NULs\n",
    "\n",
    "       \x1b[0;32;1mexcl\x1b[0m   fail if the output file already exists\n",
    "\n",
    "       \x1b[0;32;1mnocreat\x1b[0m\n",
    "              do not create the output file\n",
    "\n",
    "       \x1b[0;32;1mnotrunc\x1b[0m\n",
    "              do not truncate the output file\n",
    "\n",
    "       \x1b[0;32;1mnoerror\x1b[0m\n",
    "              continue after read errors\n",
    "\n",
    "       \x1b[0;32;1mfdatasync\x1b[0m\n",
    "              physically write output file data before finishing\n",
    "       \x1b[0;32;1mfsync\x1b[0m  likewise, but also write metadata\n",
    "\n",
    "       Each \x1b[0;33;1mFLAG\x1b[0m symbol may be:\n",
    "\n",
    "       \x1b[0;32;1mappend\x1b[0m append mode (makes sense only for output; conv=notrunc\n",
    "              suggested)\n",
    "\n",
    "       \x1b[0;32;1mdirect\x1b[0m use direct I/O for data\n",
    "\n",
    "       \x1b[0;32;1mdirectory\x1b[0m\n",
    "              fail unless a directory\n",
    "\n",
    "       \x1b[0;32;1mdsync\x1b[0m  use synchronized I/O for data\n",
    "\n",
    "       \x1b[0;32;1msync\x1b[0m   likewise, but also for metadata\n",
    "\n",
    "       \x1b[0;32;1mfullblock\x1b[0m\n",
    "              accumulate full blocks of input (iflag only)\n",
    "\n",
    "       \x1b[0;32;1mnonblock\x1b[0m\n",
    "              use non-blocking I/O\n",
    "\n",
    "       \x1b[0;32;1mnoatime\x1b[0m\n",
    "              do not update access time\n",
    "\n",
    "       \x1b[0;32;1mnocache\x1b[0m\n",
    "              Request to drop cache.  See also oflag=sync\n",
    "\n",
    "       \x1b[0;32;1mnoctty\x1b[0m do not assign controlling terminal from file\n",
    "\n",
    "       \x1b[0;32;1mnofollow\x1b[0m\n",
    "              do not follow symlinks\n",
    "\n",
    "       \x1b[0;32;1mcount_bytes\x1b[0m\n",
    "              treat 'count=N' as a byte count (iflag only)\n",
    "\n",
    "       \x1b[0;32;1mskip_bytes\x1b[0m\n",
    "              treat 'skip=N' as a byte count (iflag only)\n",
    "\n",
    "       \x1b[0;32;1mseek_bytes\x1b[0m\n",
    "              treat 'seek=N' as a byte count (oflag only)\n",
);
